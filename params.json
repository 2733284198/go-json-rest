{"name":"Go-json-rest","tagline":"A quick and easy way to setup a RESTful JSON API","body":"\r\n# Go-Json-Rest\r\n\r\n*A quick and easy way to setup a RESTful JSON API*\r\n\r\n[![Build Status](https://travis-ci.org/ant0ine/go-json-rest.png?branch=master)](https://travis-ci.org/ant0ine/go-json-rest) [![GoDoc](https://godoc.org/github.com/ant0ine/go-json-rest?status.png)](https://godoc.org/github.com/ant0ine/go-json-rest/rest)\r\n\r\n\r\n**Go-Json-Rest** is a thin layer on top of `net/http` that helps building RESTful JSON APIs easily. It provides fast URL routing using a Trie based implementation, helpers to deal with JSON requests and responses, and middlewares for additional functionalities like CORS, Auth, Gzip ...\r\n\r\n\r\n## Table of content\r\n\r\n- [Features](#features)\r\n- [Install](#install)\r\n- [Vendoring](#vendoring)\r\n- [Examples](#examples)\r\n  - [Basics](#basics)\r\n\t  - [Hello World!](#hello-world)\r\n\t  - [Countries](#countries)\r\n\t  - [Users](#users)\r\n\t  - [Lookup](#lookup)\r\n  - [Applications](#applications)\r\n\t  - [API and static files](#api-and-static-files)\r\n\t  - [GORM](#gorm)\r\n\t  - [CORS](#cors)\r\n\t  - [Basic Auth](#basic-auth)\r\n\t  - [Status](#status)\r\n\t  - [Status Auth](#status-auth)\r\n  - [Advanced](#advanced)\r\n\t  - [Streaming](#streaming)\r\n\t  - [Non JSON payload](#non-json-payload)\r\n\t  - [API Versioning](#api-versioning)\r\n\t  - [Statsd](#statsd)\r\n\t  - [SPDY](#spdy)\r\n\t  - [Google App Engine](#gae)\r\n\t  - [Basic Auth Custom](#basic-auth-custom)\r\n\t  - [CORS Custom](#cors-custom)\r\n- [External Documentation](#external-documentation)\r\n- [Options](#options)\r\n- [Version 2 release notes](#version-2-release-notes)\r\n- [Migration guide from v1 to v2](#migration-guide-from-v1-to-v2)\r\n- [Thanks](#thanks)\r\n\r\n\r\n## Features\r\n\r\n- Many examples.\r\n- Fast and scalable URL routing. It implements the classic route description syntax using a scalable trie data structure.\r\n- Use Middlewares in order to implement and extend the functionalities. (Logging, Gzip, CORS, Auth, ...)\r\n- Implemented as a `net/http` Handler. This standard interface allows combinations with other Handlers.\r\n- Test package to help writing tests for your API.\r\n- Monitoring statistics inspired by Memcached.\r\n\r\n\r\n## Install\r\n\r\nThis package is \"go-gettable\", just do:\r\n\r\n    go get github.com/ant0ine/go-json-rest/rest\r\n\r\n\r\n## Vendoring\r\n\r\nThe recommended way of using this library in your project is to use the **\"vendoring\"** method,\r\nwhere this library code is copied in your repository at a specific revision.\r\n[This page](http://nathany.com/go-packages/) is a good summary of package management in Go.\r\n\r\n\r\n## Examples\r\n\r\nAll the following examples can be found in dedicated examples repository: https://github.com/ant0ine/go-json-rest-examples\r\n\r\n### Basics\r\n\r\nFirst examples to try, as an introduction to go-json-rest.\r\n\r\n#### Hello World!\r\n\r\nTradition!\r\n\r\nThe curl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/message\r\n```\r\n\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.WriteJson(&Message{\r\n\t\t\t\tBody: \"Hello World!\",\r\n\t\t\t})\r\n\t\t}},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\n```\r\n\r\n#### Countries\r\n\r\nDemonstrate simple POST GET and DELETE operations\r\n\r\nThe curl demo:\r\n```\r\ncurl -i -d '{\"Code\":\"FR\",\"Name\":\"France\"}' http://127.0.0.1:8080/countries\r\ncurl -i -d '{\"Code\":\"US\",\"Name\":\"United States\"}' http://127.0.0.1:8080/countries\r\ncurl -i http://127.0.0.1:8080/countries/FR\r\ncurl -i http://127.0.0.1:8080/countries/US\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i -X DELETE http://127.0.0.1:8080/countries/FR\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i -X DELETE http://127.0.0.1:8080/countries/US\r\ncurl -i http://127.0.0.1:8080/countries\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"sync\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tEnableRelaxedContentType: true,\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/countries\", GetAllCountries},\r\n\t\t&rest.Route{\"POST\", \"/countries\", PostCountry},\r\n\t\t&rest.Route{\"GET\", \"/countries/:code\", GetCountry},\r\n\t\t&rest.Route{\"DELETE\", \"/countries/:code\", DeleteCountry},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nvar store = map[string]*Country{}\r\n\r\nvar lock = sync.RWMutex{}\r\n\r\nfunc GetCountry(w rest.ResponseWriter, r *rest.Request) {\r\n\tcode := r.PathParam(\"code\")\r\n\r\n\tlock.RLock()\r\n\tvar country *Country\r\n\tif store[code] != nil {\r\n\t\tcountry = &Country{}\r\n\t\t*country = *store[code]\r\n\t}\r\n\tlock.RUnlock()\r\n\r\n\tif country == nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(country)\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tlock.RLock()\r\n\tcountries := make([]Country, len(store))\r\n\ti := 0\r\n\tfor _, country := range store {\r\n\t\tcountries[i] = *country\r\n\t\ti++\r\n\t}\r\n\tlock.RUnlock()\r\n\tw.WriteJson(&countries)\r\n}\r\n\r\nfunc PostCountry(w rest.ResponseWriter, r *rest.Request) {\r\n\tcountry := Country{}\r\n\terr := r.DecodeJsonPayload(&country)\r\n\tif err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tif country.Code == \"\" {\r\n\t\trest.Error(w, \"country code required\", 400)\r\n\t\treturn\r\n\t}\r\n\tif country.Name == \"\" {\r\n\t\trest.Error(w, \"country name required\", 400)\r\n\t\treturn\r\n\t}\r\n\tlock.Lock()\r\n\tstore[country.Code] = &country\r\n\tlock.Unlock()\r\n\tw.WriteJson(&country)\r\n}\r\n\r\nfunc DeleteCountry(w rest.ResponseWriter, r *rest.Request) {\r\n\tcode := r.PathParam(\"code\")\r\n\tlock.Lock()\r\n\tdelete(store, code)\r\n\tlock.Unlock()\r\n\tw.WriteHeader(http.StatusOK)\r\n}\r\n\r\n```\r\n\r\n#### Users\r\n\r\nDemonstrate how to use Method Values.\r\n\r\nMethod Values have been [introduced in Go 1.1](https://golang.org/doc/go1.1#method_values).\r\n\r\nUntil then `rest.RouteObjectMethod` was provided, this method is now deprecated.\r\n\r\nThis shows how to map a Route to a method of an instantiated object (eg: receiver of the method)\r\n\r\nThe curl demo:\r\n```\r\ncurl -i -d '{\"Name\":\"Antoine\"}' http://127.0.0.1:8080/users\r\ncurl -i http://127.0.0.1:8080/users/0\r\ncurl -i -X PUT -d '{\"Name\":\"Antoine Imbert\"}' http://127.0.0.1:8080/users/0\r\ncurl -i -X DELETE http://127.0.0.1:8080/users/0\r\ncurl -i http://127.0.0.1:8080/users\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"sync\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\tusers := Users{\r\n\t\tStore: map[string]*User{},\r\n\t}\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tEnableRelaxedContentType: true,\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/users\", users.GetAllUsers},\r\n\t\t&rest.Route{\"POST\", \"/users\", users.PostUser},\r\n\t\t&rest.Route{\"GET\", \"/users/:id\", users.GetUser},\r\n\t\t&rest.Route{\"PUT\", \"/users/:id\", users.PutUser},\r\n\t\t&rest.Route{\"DELETE\", \"/users/:id\", users.DeleteUser},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype User struct {\r\n\tId   string\r\n\tName string\r\n}\r\n\r\ntype Users struct {\r\n\tsync.RWMutex\r\n\tStore map[string]*User\r\n}\r\n\r\nfunc (u *Users) GetAllUsers(w rest.ResponseWriter, r *rest.Request) {\r\n\tu.RLock()\r\n\tusers := make([]User, len(u.Store))\r\n\ti := 0\r\n\tfor _, user := range u.Store {\r\n\t\tusers[i] = *user\r\n\t\ti++\r\n\t}\r\n\tu.RUnlock()\r\n\tw.WriteJson(&users)\r\n}\r\n\r\nfunc (u *Users) GetUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\tu.RLock()\r\n\tvar user *User\r\n\tif u.Store[id] != nil {\r\n\t\tuser = &User{}\r\n\t\t*user = *u.Store[id]\r\n\t}\r\n\tu.RUnlock()\r\n\tif user == nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(user)\r\n}\r\n\r\nfunc (u *Users) PostUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tuser := User{}\r\n\terr := r.DecodeJsonPayload(&user)\r\n\tif err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tu.Lock()\r\n\tid := fmt.Sprintf(\"%d\", len(u.Store)) // stupid\r\n\tuser.Id = id\r\n\tu.Store[id] = &user\r\n\tu.Unlock()\r\n\tw.WriteJson(&user)\r\n}\r\n\r\nfunc (u *Users) PutUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\tu.Lock()\r\n\tif u.Store[id] == nil {\r\n\t\trest.NotFound(w, r)\r\n\t\tu.Unlock()\r\n\t\treturn\r\n\t}\r\n\tuser := User{}\r\n\terr := r.DecodeJsonPayload(&user)\r\n\tif err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\tu.Unlock()\r\n\t\treturn\r\n\t}\r\n\tuser.Id = id\r\n\tu.Store[id] = &user\r\n\tu.Unlock()\r\n\tw.WriteJson(&user)\r\n}\r\n\r\nfunc (u *Users) DeleteUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\tu.Lock()\r\n\tdelete(u.Store, id)\r\n\tu.Unlock()\r\n\tw.WriteHeader(http.StatusOK)\r\n}\r\n\r\n```\r\n\r\n#### Lookup\r\n\r\nDemonstrate how to use the relaxed placeholder (notation #paramName).\r\nThis placeholder matches everything until the first `/`, including `.`\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/lookup/google.com\r\ncurl -i http://127.0.0.1:8080/lookup/notadomain\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/lookup/#host\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tip, err := net.LookupIP(req.PathParam(\"host\"))\r\n\t\t\tif err != nil {\r\n\t\t\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tw.WriteJson(&ip)\r\n\t\t}},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\n```\r\n\r\n\r\n### Applications\r\n\r\nCommon use cases, found in many applications.\r\n\r\n#### API and static files\r\n\r\nCombine Go-Json-Rest with other handlers.\r\n\r\n`rest.ResourceHandler` is a valid `http.Handler`, and can be combined with other handlers.\r\nIn this example the ResourceHandler is used under the `/api/` prefix, while a FileServer is instantiated under the `/static/` prefix.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/api/message\r\ncurl -i http://127.0.0.1:8080/static/main.go\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.WriteJson(&Message{\r\n\t\t\t\tBody: \"Hello World!\",\r\n\t\t\t})\r\n\t\t}},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\thttp.Handle(\"/api/\", http.StripPrefix(\"/api\", &handler))\r\n\r\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static\", http.FileServer(http.Dir(\".\"))))\r\n\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\n```\r\n\r\n#### GORM\r\n\r\nDemonstrate basic CRUD operation using a store based on MySQL and GORM\r\n\r\n[GORM](https://github.com/jinzhu/gorm) is simple ORM library for Go.\r\nIn this example the same struct is used both as the GORM model and as the JSON model.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i -d '{\"Message\":\"this is a test\"}' http://127.0.0.1:8080/reminders\r\ncurl -i http://127.0.0.1:8080/reminders/1\r\ncurl -i http://127.0.0.1:8080/reminders\r\ncurl -i -X PUT -d '{\"Message\":\"is updated\"}' http://127.0.0.1:8080/reminders/1\r\ncurl -i -X DELETE http://127.0.0.1:8080/reminders/1\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t_ \"github.com/go-sql-driver/mysql\"\r\n\t\"github.com/jinzhu/gorm\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\tapi := Api{}\r\n\tapi.InitDB()\r\n\tapi.InitSchema()\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tEnableRelaxedContentType: true,\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/reminders\", api.GetAllReminders},\r\n\t\t&rest.Route{\"POST\", \"/reminders\", api.PostReminder},\r\n\t\t&rest.Route{\"GET\", \"/reminders/:id\", api.GetReminder},\r\n\t\t&rest.Route{\"PUT\", \"/reminders/:id\", api.PutReminder},\r\n\t\t&rest.Route{\"DELETE\", \"/reminders/:id\", api.DeleteReminder},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Reminder struct {\r\n\tId        int64     `json:\"id\"`\r\n\tMessage   string    `sql:\"size:1024\" json:\"message\"`\r\n\tCreatedAt time.Time `json:\"createdAt\"`\r\n\tUpdatedAt time.Time `json:\"updatedAt\"`\r\n\tDeletedAt time.Time `json:\"-\"`\r\n}\r\n\r\ntype Api struct {\r\n\tDB gorm.DB\r\n}\r\n\r\nfunc (api *Api) InitDB() {\r\n\tvar err error\r\n\tapi.DB, err = gorm.Open(\"mysql\", \"gorm:gorm@/gorm?charset=utf8&parseTime=True\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Got error when connect database, the error is '%v'\", err)\r\n\t}\r\n\tapi.DB.LogMode(true)\r\n}\r\n\r\nfunc (api *Api) InitSchema() {\r\n\tapi.DB.AutoMigrate(Reminder{})\r\n}\r\n\r\nfunc (api *Api) GetAllReminders(w rest.ResponseWriter, r *rest.Request) {\r\n\treminders := []Reminder{}\r\n\tapi.DB.Find(&reminders)\r\n\tw.WriteJson(&reminders)\r\n}\r\n\r\nfunc (api *Api) GetReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\treminder := Reminder{}\r\n\tif api.DB.First(&reminder, id).Error != nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(&reminder)\r\n}\r\n\r\nfunc (api *Api) PostReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\treminder := Reminder{}\r\n\tif err := r.DecodeJsonPayload(&reminder); err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tif err := api.DB.Save(&reminder).Error; err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(&reminder)\r\n}\r\n\r\nfunc (api *Api) PutReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\r\n\tid := r.PathParam(\"id\")\r\n\treminder := Reminder{}\r\n\tif api.DB.First(&reminder, id).Error != nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\r\n\tupdated := Reminder{}\r\n\tif err := r.DecodeJsonPayload(&updated); err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\r\n\treminder.Message = updated.Message\r\n\r\n\tif err := api.DB.Save(&reminder).Error; err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(&reminder)\r\n}\r\n\r\nfunc (api *Api) DeleteReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\treminder := Reminder{}\r\n\tif api.DB.First(&reminder, id).Error != nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tif err := api.DB.Delete(&reminder).Error; err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.WriteHeader(http.StatusOK)\r\n}\r\n\r\n```\r\n\r\n#### CORS\r\n\r\nDemonstrate how to setup CorsMiddleware around all the API endpoints.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\n```\r\n\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tPreRoutingMiddlewares: []rest.Middleware{\r\n\t\t\t&rest.CorsMiddleware{\r\n\t\t\t\tRejectNonCorsRequests: false,\r\n\t\t\t\tOriginValidator: func(origin string, request *rest.Request) bool {\r\n\t\t\t\t\treturn origin == \"http://my.other.host\"\r\n\t\t\t\t},\r\n\t\t\t\tAllowedMethods: []string{\"GET\", \"POST\", \"PUT\"},\r\n\t\t\t\tAllowedHeaders: []string{\r\n\t\t\t\t\t\"Accept\", \"Content-Type\", \"X-Custom-Header\", \"Origin\"},\r\n\t\t\t\tAccessControlAllowCredentials: true,\r\n\t\t\t\tAccessControlMaxAge:           3600,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/countries\", GetAllCountries},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n#### Basic Auth\r\n\r\nDemonstrate how to setup AuthBasicMiddleware as a pre-routing middleware.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i -u admin:admin http://127.0.0.1:8080/countries\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tPreRoutingMiddlewares: []rest.Middleware{\r\n\t\t\t&rest.AuthBasicMiddleware{\r\n\t\t\t\tRealm: \"test zone\",\r\n\t\t\t\tAuthenticator: func(userId string, password string) bool {\r\n\t\t\t\t\tif userId == \"admin\" && password == \"admin\" {\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/countries\", GetAllCountries},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n#### Status\r\n\r\nDemonstrate how to setup a `/.status` endpoint\r\n\r\nInspired by memcached \"stats\", this optional feature can be enabled to help monitoring the service.\r\nThis example shows how to enable the stats, and how to setup the `/.status` route.\r\n\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/.status\r\ncurl -i http://127.0.0.1:8080/.status\r\n...\r\n```\r\n\r\nOutput example:\r\n```\r\n{\r\n  \"Pid\": 21732,\r\n  \"UpTime\": \"1m15.926272s\",\r\n  \"UpTimeSec\": 75.926272,\r\n  \"Time\": \"2013-03-04 08:00:27.152986 +0000 UTC\",\r\n  \"TimeUnix\": 1362384027,\r\n  \"StatusCodeCount\": {\r\n        \"200\": 53,\r\n        \"404\": 11\r\n  },\r\n  \"TotalCount\": 64,\r\n  \"TotalResponseTime\": \"16.777ms\",\r\n  \"TotalResponseTimeSec\": 0.016777,\r\n  \"AverageResponseTime\": \"262.14us\",\r\n  \"AverageResponseTimeSec\": 0.00026214\r\n}\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{\r\n\t\tEnableStatusService: true,\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/.status\",\r\n\t\t\tfunc(w rest.ResponseWriter, r *rest.Request) {\r\n\t\t\t\tw.WriteJson(handler.GetStatus())\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\n```\r\n\r\n#### Status Auth\r\n\r\nDemonstrate how to setup a /.status endpoint protected with basic authentication.\r\n\r\nThis is a good use case of middleware applied to only one API endpoint.\r\n\r\nThe Curl Demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i http://127.0.0.1:8080/.status\r\ncurl -i -u admin:admin http://127.0.0.1:8080/.status\r\n...\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{\r\n\t\tEnableStatusService: true,\r\n\t}\r\n\tauth := &rest.AuthBasicMiddleware{\r\n\t\tRealm: \"test zone\",\r\n\t\tAuthenticator: func(userId string, password string) bool {\r\n\t\t\tif userId == \"admin\" && password == \"admin\" {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/countries\", GetAllCountries},\r\n\t\t&rest.Route{\"GET\", \"/.status\",\r\n\t\t\tauth.MiddlewareFunc(\r\n\t\t\t\tfunc(w rest.ResponseWriter, r *rest.Request) {\r\n\t\t\t\t\tw.WriteJson(handler.GetStatus())\r\n\t\t\t\t},\r\n\t\t\t),\r\n\t\t},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n\r\n### Advanced\r\n\r\nLess common use cases.\r\n\r\n#### Streaming\r\n\r\nDemonstrate a streaming REST API, where the data is \"flushed\" to the client ASAP.\r\n\r\nThe stream format is a Line Delimited JSON.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/stream\r\n```\r\n\r\nOutput:\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\nDate: Sun, 16 Feb 2014 00:39:19 GMT\r\nTransfer-Encoding: chunked\r\n\r\n{\"Name\":\"thing #1\"}\r\n{\"Name\":\"thing #2\"}\r\n{\"Name\":\"thing #3\"}\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tEnableRelaxedContentType: true,\r\n\t\tDisableJsonIndent:        true,\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/stream\", StreamThings},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Thing struct {\r\n\tName string\r\n}\r\n\r\nfunc StreamThings(w rest.ResponseWriter, r *rest.Request) {\r\n\tcpt := 0\r\n\tfor {\r\n\t\tcpt++\r\n\t\tw.WriteJson(\r\n\t\t\t&Thing{\r\n\t\t\t\tName: fmt.Sprintf(\"thing #%d\", cpt),\r\n\t\t\t},\r\n\t\t)\r\n\t\tw.(http.ResponseWriter).Write([]byte(\"\\n\"))\r\n\t\t// Flush the buffer to client\r\n\t\tw.(http.Flusher).Flush()\r\n\t\t// wait 3 seconds\r\n\t\ttime.Sleep(time.Duration(3) * time.Second)\r\n\t}\r\n}\r\n\r\n```\r\n\r\n#### Non JSON payload\r\n\r\nExceptional use of non JSON payloads.\r\n\r\nThe ResponseWriter implementation provided by go-json-rest is designed\r\nto build JSON responses. In order to serve different kind of content,\r\nit is recommended to either:\r\na) use another server and configure CORS\r\n   (see the cors/ example)\r\nb) combine the rest.ResourceHandler with another http.Handler\r\n   (see api-and-static/ example)\r\n\r\nThat been said, exceptionally, it can be convenient to return a\r\ndifferent content type on a JSON endpoint. In this case, setting the\r\nContent-Type and using the type assertion to access the Write method\r\nis enough. As shown in this example.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/message.txt\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/message.txt\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\r\n\t\t\tw.(http.ResponseWriter).Write([]byte(\"Hello World!\"))\r\n\t\t}},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\n```\r\n\r\n#### API Versioning\r\n\r\nFirst, API versioning is not easy and you may want to favor a mechanism that uses only backward compatible changes and deprecation cycles.\r\n\r\nThat been said, here is an example of API versioning using [Semver](http://semver.org/)\r\n\r\nIt defines a middleware that parses the version, checks a min and a max, and makes it available in the `request.Env`.\r\n\r\n(TODO, there is an obvious need for PostRoutingMiddlewares here.)\r\n\r\nThe curl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/api/1.0.0/message\r\ncurl -i http://127.0.0.1:8080/api/2.0.0/message\r\ncurl -i http://127.0.0.1:8080/api/2.0.1/message\r\ncurl -i http://127.0.0.1:8080/api/0.0.1/message\r\ncurl -i http://127.0.0.1:8080/api/4.0.1/message\r\n\r\n```\r\n\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/coreos/go-semver/semver\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype SemVerMiddleware struct {\r\n\tMinVersion string\r\n\tMaxVersion string\r\n}\r\n\r\nfunc (mw *SemVerMiddleware) MiddlewareFunc(handler rest.HandlerFunc) rest.HandlerFunc {\r\n\r\n\tminVersion, err := semver.NewVersion(mw.MinVersion)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tmaxVersion, err := semver.NewVersion(mw.MaxVersion)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\treturn func(writer rest.ResponseWriter, request *rest.Request) {\r\n\r\n\t\tversion, err := semver.NewVersion(request.PathParam(\"version\"))\r\n\t\tif err != nil {\r\n\t\t\trest.Error(writer, \"Invalid version: \"+err.Error(), http.StatusBadRequest)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif version.LessThan(*minVersion) {\r\n\t\t\trest.Error(writer, \"Min supported version is \"+minVersion.String(), http.StatusBadRequest)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif maxVersion.LessThan(*version) {\r\n\t\t\trest.Error(writer, \"Max supported version is \"+maxVersion.String(), http.StatusBadRequest)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\trequest.Env[\"VERSION\"] = version\r\n\t\thandler(writer, request)\r\n\t}\r\n}\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{}\r\n\tsvmw := SemVerMiddleware{\r\n\t\tMinVersion: \"1.0.0\",\r\n\t\tMaxVersion: \"3.0.0\",\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/#version/message\", svmw.MiddlewareFunc(\r\n\t\t\tfunc(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\t\tversion := req.Env[\"VERSION\"].(*semver.Version)\r\n\t\t\t\tif version.Major == 2 {\r\n                                        // http://en.wikipedia.org/wiki/Second-system_effect\r\n\t\t\t\t\tw.WriteJson(&Message{\"Hello broken World!\"})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tw.WriteJson(&Message{\"Hello World!\"})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t)},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\thttp.Handle(\"/api/\", http.StripPrefix(\"/api\", &handler))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\n```\r\n\r\n#### Statsd\r\n\r\nDemonstrate how to use OuterMiddlewares to do additional logging and reporting.\r\n\r\nHere `request.Env[\"STATUS_CODE\"]` and `request.Env[\"ELAPSED_TIME\"]` that are available to outer middlewares are used with the [g2s](https://github.com/peterbourgon/g2s) statsd client to send these metrics to statsd.\r\n\r\nThe curl demo:\r\n``` sh\r\n# start statsd server\r\n# monitor network\r\nngrep -d any port 8125\r\n\r\ncurl -i http://127.0.0.1:8080/message\r\ncurl -i http://127.0.0.1:8080/doesnotexist\r\n\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/peterbourgon/g2s\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"strconv\"\r\n\t\"time\"\r\n)\r\n\r\ntype StatsdMiddleware struct {\r\n\tIpPort string\r\n\tPrefix string\r\n}\r\n\r\nfunc (mw *StatsdMiddleware) MiddlewareFunc(handler rest.HandlerFunc) rest.HandlerFunc {\r\n\r\n\tstatsd, err := g2s.Dial(\"udp\", mw.IpPort)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tkeyBase := \"\"\r\n\tif mw.Prefix != \"\" {\r\n\t\tkeyBase += mw.Prefix + \".\"\r\n\t}\r\n\tkeyBase += \"response.\"\r\n\r\n\treturn func(writer rest.ResponseWriter, request *rest.Request) {\r\n\r\n\t\thandler(writer, request)\r\n\r\n\t\tstatusCode := request.Env[\"STATUS_CODE\"].(int)\r\n\t\tstatsd.Counter(1.0, keyBase+\"status_code.\"+strconv.Itoa(statusCode), 1)\r\n\r\n\t\telapsedTime := request.Env[\"ELAPSED_TIME\"].(*time.Duration)\r\n\t\tstatsd.Timing(1.0, keyBase+\"elapsed_time\", *elapsedTime)\r\n\t}\r\n}\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{\r\n\t\tOuterMiddlewares: []rest.Middleware{\r\n\t\t\t&StatsdMiddleware{\r\n\t\t\t\tIpPort: \"localhost:8125\",\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\r\n\t\t\t// take more than 1ms so statsd can report it\r\n\t\t\ttime.Sleep(100 * time.Millisecond)\r\n\r\n\t\t\tw.WriteJson(&Message{\r\n\t\t\t\tBody: \"Hello World!\",\r\n\t\t\t})\r\n\t\t}},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\n```\r\n\r\n#### SPDY\r\n\r\nDemonstrate how to use SPDY with https://github.com/shykes/spdy-go\r\n\r\nFor a command line client, install spdycat from:\r\nhttps://github.com/tatsuhiro-t/spdylay\r\n\r\nThe spdycat demo:\r\n```\r\nspdycat -v --no-tls -2 http://localhost:8080/users/0\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/shykes/spdy-go\"\r\n\t\"log\"\r\n)\r\n\r\ntype User struct {\r\n\tId   string\r\n\tName string\r\n}\r\n\r\nfunc GetUser(w rest.ResponseWriter, req *rest.Request) {\r\n\tuser := User{\r\n\t\tId:   req.PathParam(\"id\"),\r\n\t\tName: \"Antoine\",\r\n\t}\r\n\tw.WriteJson(&user)\r\n}\r\n\r\nfunc main() {\r\n\thandler := rest.ResourceHandler{}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/users/:id\", GetUser},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(spdy.ListenAndServeTCP(\":8080\", &handler))\r\n}\r\n\r\n```\r\n\r\n#### GAE\r\n\r\nDemonstrate a simple Google App Engine app\r\n\r\nHere are my steps to make it work with the GAE SDK.\r\n(Probably not the best ones)\r\n\r\nAssuming that go-json-rest is installed using \"go get\"\r\nand that the GAE SDK is also installed.\r\n\r\nSetup:\r\n * copy this examples/gae/ dir outside of the go-json-rest/ tree\r\n * cd gae/\r\n * mkdir -p github.com/ant0ine\r\n * cp -r $GOPATH/src/github.com/ant0ine/go-json-rest github.com/ant0ine/go-json-rest\r\n * rm -rf github.com/ant0ine/go-json-rest/examples/\r\n * path/to/google_appengine/dev_appserver.py .\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/message\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage gaehelloworld\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc init() {\r\n\thandler := rest.ResourceHandler{}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.WriteJson(&Message{\r\n\t\t\t\tBody: \"Hello World!\",\r\n\t\t\t})\r\n\t\t}},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\thttp.Handle(\"/\", &handler)\r\n}\r\n\r\n```\r\n\r\n#### Basic Auth Custom\r\n\r\nDemonstrate how to implement a custom AuthBasic middleware, used to protect all endpoints.\r\n\r\nThis is a very simple version supporting only one user.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"encoding/base64\"\r\n\t\"errors\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"strings\"\r\n)\r\n\r\ntype MyAuthBasicMiddleware struct {\r\n\tRealm    string\r\n\tUserId   string\r\n\tPassword string\r\n}\r\n\r\nfunc (mw *MyAuthBasicMiddleware) MiddlewareFunc(handler rest.HandlerFunc) rest.HandlerFunc {\r\n\treturn func(writer rest.ResponseWriter, request *rest.Request) {\r\n\r\n\t\tauthHeader := request.Header.Get(\"Authorization\")\r\n\t\tif authHeader == \"\" {\r\n\t\t\tmw.unauthorized(writer)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tprovidedUserId, providedPassword, err := mw.decodeBasicAuthHeader(authHeader)\r\n\r\n\t\tif err != nil {\r\n\t\t\trest.Error(writer, \"Invalid authentication\", http.StatusBadRequest)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif !(providedUserId == mw.UserId && providedPassword == mw.Password) {\r\n\t\t\tmw.unauthorized(writer)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\thandler(writer, request)\r\n\t}\r\n}\r\n\r\nfunc (mw *MyAuthBasicMiddleware) unauthorized(writer rest.ResponseWriter) {\r\n\twriter.Header().Set(\"WWW-Authenticate\", \"Basic realm=\"+mw.Realm)\r\n\trest.Error(writer, \"Not Authorized\", http.StatusUnauthorized)\r\n}\r\n\r\nfunc (mw *MyAuthBasicMiddleware) decodeBasicAuthHeader(header string) (user string, password string, err error) {\r\n\r\n\tparts := strings.SplitN(header, \" \", 2)\r\n\tif !(len(parts) == 2 && parts[0] == \"Basic\") {\r\n\t\treturn \"\", \"\", errors.New(\"Invalid authentication\")\r\n\t}\r\n\r\n\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\r\n\tif err != nil {\r\n\t\treturn \"\", \"\", errors.New(\"Invalid base64\")\r\n\t}\r\n\r\n\tcreds := strings.SplitN(string(decoded), \":\", 2)\r\n\tif len(creds) != 2 {\r\n\t\treturn \"\", \"\", errors.New(\"Invalid authentication\")\r\n\t}\r\n\r\n\treturn creds[0], creds[1], nil\r\n}\r\n\r\nfunc main() {\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tPreRoutingMiddlewares: []rest.Middleware{\r\n\t\t\t&MyAuthBasicMiddleware{\r\n\t\t\t\tRealm:    \"Administration\",\r\n\t\t\t\tUserId:   \"admin\",\r\n\t\t\t\tPassword: \"admin\",\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/countries\", GetAllCountries},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n#### CORS Custom\r\n\r\nDemonstrate how to implement a custom CORS middleware, used to on all endpoints.\r\n\r\nThe curl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\n```\r\n\r\nGo code:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype MyCorsMiddleware struct{}\r\n\r\nfunc (mw *MyCorsMiddleware) MiddlewareFunc(handler rest.HandlerFunc) rest.HandlerFunc {\r\n\treturn func(writer rest.ResponseWriter, request *rest.Request) {\r\n\r\n\t\tcorsInfo := request.GetCorsInfo()\r\n\r\n\t\t// Be nice with non CORS requests, continue\r\n\t\t// Alternatively, you may also chose to only allow CORS requests, and return an error.\r\n\t\tif !corsInfo.IsCors {\r\n\t\t\t// continure, execute the wrapped middleware\r\n\t\t\thandler(writer, request)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Validate the Origin\r\n\t\t// More sophisticated validations can be implemented, regexps, DB lookups, ...\r\n\t\tif corsInfo.Origin != \"http://my.other.host\" {\r\n\t\t\trest.Error(writer, \"Invalid Origin\", http.StatusForbidden)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif corsInfo.IsPreflight {\r\n\t\t\t// check the request methods\r\n\t\t\tallowedMethods := map[string]bool{\r\n\t\t\t\t\"GET\":  true,\r\n\t\t\t\t\"POST\": true,\r\n\t\t\t\t\"PUT\":  true,\r\n\t\t\t\t// don't allow DELETE, for instance\r\n\t\t\t}\r\n\t\t\tif !allowedMethods[corsInfo.AccessControlRequestMethod] {\r\n\t\t\t\trest.Error(writer, \"Invalid Preflight Request\", http.StatusForbidden)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t// check the request headers\r\n\t\t\tallowedHeaders := map[string]bool{\r\n\t\t\t\t\"Accept\":          true,\r\n\t\t\t\t\"Content-Type\":    true,\r\n\t\t\t\t\"X-Custom-Header\": true,\r\n\t\t\t}\r\n\t\t\tfor _, requestedHeader := range corsInfo.AccessControlRequestHeaders {\r\n\t\t\t\tif !allowedHeaders[requestedHeader] {\r\n\t\t\t\t\trest.Error(writer, \"Invalid Preflight Request\", http.StatusForbidden)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor allowedMethod, _ := range allowedMethods {\r\n\t\t\t\twriter.Header().Add(\"Access-Control-Allow-Methods\", allowedMethod)\r\n\t\t\t}\r\n\t\t\tfor allowedHeader, _ := range allowedHeaders {\r\n\t\t\t\twriter.Header().Add(\"Access-Control-Allow-Headers\", allowedHeader)\r\n\t\t\t}\r\n\t\t\twriter.Header().Set(\"Access-Control-Allow-Origin\", corsInfo.Origin)\r\n\t\t\twriter.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\r\n\t\t\twriter.Header().Set(\"Access-Control-Max-Age\", \"3600\")\r\n\t\t\twriter.WriteHeader(http.StatusOK)\r\n\t\t\treturn\r\n\t\t} else {\r\n\t\t\twriter.Header().Set(\"Access-Control-Expose-Headers\", \"X-Powered-By\")\r\n\t\t\twriter.Header().Set(\"Access-Control-Allow-Origin\", corsInfo.Origin)\r\n\t\t\twriter.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\r\n\t\t\t// continure, execute the wrapped middleware\r\n\t\t\thandler(writer, request)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\r\n\thandler := rest.ResourceHandler{\r\n\t\tPreRoutingMiddlewares: []rest.Middleware{\r\n\t\t\t&MyCorsMiddleware{},\r\n\t\t},\r\n\t}\r\n\terr := handler.SetRoutes(\r\n\t\t&rest.Route{\"GET\", \"/countries\", GetAllCountries},\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", &handler))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## External Documentation\r\n\r\n- [Online Documentation (godoc.org)](http://godoc.org/github.com/ant0ine/go-json-rest/rest)\r\n\r\nOld v1 blog posts:\r\n\r\n- [(Blog Post) Introducing Go-Json-Rest] (http://blog.ant0ine.com/typepad/2013/04/introducing-go-json-rest.html)\r\n- [(Blog Post) Better URL Routing ?] (http://blog.ant0ine.com/typepad/2013/02/better-url-routing-golang-1.html)\r\n\r\n\r\n## Options\r\n\r\nThings to enable in production:\r\n- Gzip compression (default: disabled)\r\n- Custom Logger (default: Go default)\r\n\r\nThings to enable in development:\r\n- Json indentation (default: enabled)\r\n- Relaxed ContentType (default: disabled)\r\n- Error stack trace in the response body (default: disabled)\r\n\r\n\r\n## Version 2 release notes\r\n\r\n* Middlewares, the notion of middleware is now formally defined. They can be setup as global pre-routing Middlewares wrapping all the endpoints, or on a per endpoint basis.\r\nIn fact the internal code of **go-json-rest** is itself implemented with Middlewares, they are just hidden behind configuration boolean flags to make these very common options even easier to use.\r\n\r\n* A new ResponseWriter. This is now an interface, and allows Middlewares to wrap the writer. The provided writer implements, in addition of *rest.ResponseWriter*, *http.Flusher*, *http.CloseNotifier*, *http.Hijacker*, and *http.ResponseWriter*. A lot more Go-ish, and very similar to `net/http`.\r\n\r\n* The AuthBasic and CORS Middlewares have been added. More to come in the future.\r\n\r\n* Faster, more tasks are performed at init time, and less for each request.\r\n\r\n* New documentation, with more examples.\r\n\r\n* A lot of other small improvements, See the [Migration guide to v2](#migration-guide-from-v1-to-v2)\r\n\r\n\r\n## Migration guide from v1 to v2\r\n\r\n**Go-Json-Rest** follows [Semver](http://semver.org/) and a few breaking changes have been introduced with the v2.\r\n\r\n\r\n#### The import path has changed to `github.com/ant0ine/go-json-rest/rest`\r\n\r\nThis is more conform to Go style, and makes [goimports](https://godoc.org/code.google.com/p/go.tools/cmd/goimports) work.\r\n\r\nThis:\r\n``` go\r\nimport (\r\n        \"github.com/ant0ine/go-json-rest\"\r\n)\r\n```\r\nhas to be changed to this:\r\n``` go\r\nimport (\r\n        \"github.com/ant0ine/go-json-rest/rest\"\r\n)\r\n```\r\n\r\n\r\n#### rest.ResponseWriter is now an interface\r\n\r\nThis change allows the `ResponseWriter` to be wrapped, like the one of the `net/http` package.\r\nThis is much more powerful, and allows the creation of Middlewares that wrap the writer. The gzip option, for instance, uses this to encode the payload (see gzip.go).\r\n\r\nThis:\r\n``` go\r\nfunc (w *rest.ResponseWriter, req *rest.Request) {\r\n        ...\r\n}\r\n```\r\nhas to be changed to this:\r\n``` go\r\nfunc (w rest.ResponseWriter, req *rest.Request) {\r\n        ...\r\n}\r\n```\r\n\r\n\r\n#### SetRoutes now takes pointers to Route\r\n\r\nInstead of copying Route structures everywhere, pointers are now used. This is more elegant, more efficient, and will allow more sophisticated Route manipulations in the future (like reverse route resolution).\r\n\r\nThis:\r\n``` go\r\nhandler.SetRoutes(\r\n\t\trest.Route{\r\n\t\t      // ...\r\n\t\t},\r\n)\r\n```\r\nhas to be changed to this:\r\n``` go\r\nhandler.SetRoutes(\r\n\t\t&rest.Route{\r\n\t\t      // ...\r\n\t\t},\r\n)\r\n```\r\n\r\n\r\n####  The notion of Middleware is now formally defined\r\n\r\nA middleware is an object satisfying this interface:\r\n``` go\r\ntype Middleware interface {\r\n\tMiddlewareFunc(handler HandlerFunc) HandlerFunc\r\n}\r\n```\r\n\r\nCode using PreRoutingMiddleware will have to be adapted to provide a list of Middleware objects.\r\nSee the [Basic Auth example](https://github.com/ant0ine/go-json-rest-examples/blob/master/auth-basic/main.go).\r\n\r\n\r\n#### Flush(), CloseNotify() and Write() are not directly exposed anymore\r\n\r\nThey used to be public methods of the ResponseWriter. The implementation is still there but a type assertion of the corresponding interface is now necessary.\r\nRegarding these features, a rest.ResponseWriter now behaves exactly as the http.ResponseWriter implementation provided by net/http.\r\n\r\nThis:\r\n``` go\r\nwriter.Flush()\r\n```\r\nhas to be changed to this:\r\n``` go\r\nwriter.(http.Flusher).Flush()\r\n```\r\n\r\n\r\n#### The /.status endpoint is not created automatically anymore\r\n\r\nThe route has to be manually defined.\r\nSee the [Status example](https://github.com/ant0ine/go-json-rest-examples/blob/master/status/main.go).\r\nThis is more flexible (the route is customizable), and allows combination with Middlewarres.\r\nSee for instance how to [protect this status endpoint with the AuthBasic middleware](https://github.com/ant0ine/go-json-rest-examples/blob/master/status-auth/main.go).\r\n\r\n\r\n#### Request utility methods have changed\r\n\r\nOverall, they provide the same features, but with two methods instead of three, better names, and without the confusing `UriForWithParams`.\r\n\r\n- `func (r *Request) UriBase() url.URL` is now `func (r *Request) BaseUrl() *url.URL`, Note the pointer as the returned value.\r\n\r\n- `func (r *Request) UriForWithParams(path string, parameters map[string][]string) url.URL` is now `func (r *Request) UrlFor(path string, queryParams map[string][]string) *url.URL`.\r\n\r\n- `func (r *Request) UriFor(path string) url.URL` has be removed.\r\n\r\n\r\n## Thanks\r\n\r\n- [Franck Cuny](https://github.com/franckcuny)\r\n- [Yann Kerhervé](https://github.com/yannk)\r\n- [Ask Bjørn Hansen](https://github.com/abh)\r\n- [Paul Lam](https://github.com/Quantisan)\r\n\r\n\r\nCopyright (c) 2013-2014 Antoine Imbert\r\n\r\n[MIT License](https://github.com/ant0ine/go-json-rest/blob/master/LICENSE)\r\n","google":"UA-309210-5","note":"Don't delete this file! It's used internally to help with page regeneration."}