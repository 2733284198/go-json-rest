{"name":"Go-json-rest","tagline":"A quick and easy way to setup a RESTful JSON API","body":"\r\n# Go-Json-Rest\r\n\r\n*A quick and easy way to setup a RESTful JSON API*\r\n\r\n[![godoc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat)](https://godoc.org/github.com/ant0ine/go-json-rest/rest) [![license](https://img.shields.io/badge/license-MIT-red.svg?style=flat)](https://raw.githubusercontent.com/ant0ine/go-json-rest/master/LICENSE) [![build](https://img.shields.io/travis/ant0ine/go-json-rest.svg?style=flat)](https://travis-ci.org/ant0ine/go-json-rest)\r\n\r\n\r\n**Go-Json-Rest** is a thin layer on top of `net/http` that helps building RESTful JSON APIs easily. It provides fast and scalable request routing using a Trie based implementation, helpers to deal with JSON requests and responses, and middlewares for functionalities like CORS, Auth, Gzip, Status ...\r\n\r\n\r\n## Table of content\r\n\r\n- [Features](#features)\r\n- [Install](#install)\r\n- [Vendoring](#vendoring)\r\n- [Middlewares](#middlewares)\r\n- [Examples](#examples)\r\n  - [Basics](#basics)\r\n\t  - [Hello World!](#hello-world)\r\n\t  - [Lookup](#lookup)\r\n\t  - [Countries](#countries)\r\n\t  - [Users](#users)\r\n  - [Applications](#applications)\r\n\t  - [API and static files](#api-and-static-files)\r\n\t  - [GORM](#gorm)\r\n\t  - [CORS](#cors)\r\n\t  - [JSONP](#jsonp)\r\n\t  - [Basic Auth](#basic-auth)\r\n\t  - [Status](#status)\r\n\t  - [Status Auth](#status-auth)\r\n  - [Advanced](#advanced)\r\n\t  - [JWT](#jwt)\r\n\t  - [Streaming](#streaming)\r\n\t  - [Non JSON payload](#non-json-payload)\r\n\t  - [API Versioning](#api-versioning)\r\n\t  - [Statsd](#statsd)\r\n\t  - [NewRelic](#newrelic)\r\n\t  - [Graceful Shutdown](#graceful-shutdown)\r\n\t  - [SPDY](#spdy)\r\n\t  - [Google App Engine](#gae)\r\n\t  - [Websocket](#websocket)\r\n- [External Documentation](#external-documentation)\r\n- [Version 3 release notes](#version-3-release-notes)\r\n- [Migration guide from v2 to v3](#migration-guide-from-v2-to-v3)\r\n- [Version 2 release notes](#version-2-release-notes)\r\n- [Migration guide from v1 to v2](#migration-guide-from-v1-to-v2)\r\n- [Thanks](#thanks)\r\n\r\n\r\n## Features\r\n\r\n- Many examples.\r\n- Fast and scalable URL routing. It implements the classic route description syntax using a Trie data structure.\r\n- Architecture based on a router(App) sitting on top of a stack of Middlewares.\r\n- The Middlewares implement functionalities like Logging, Gzip, CORS, Auth, Status, ...\r\n- Implemented as a `net/http` Handler. This standard interface allows combinations with other Handlers.\r\n- Test package to help writing tests for your API.\r\n- Monitoring statistics inspired by Memcached.\r\n\r\n\r\n## Install\r\n\r\nThis package is \"go-gettable\", just do:\r\n\r\n    go get github.com/ant0ine/go-json-rest/rest\r\n\r\n\r\n## Vendoring\r\n\r\nThe recommended way of using this library in your project is to use the **\"vendoring\"** method,\r\nwhere this library code is copied in your repository at a specific revision.\r\n[This page](http://nathany.com/go-packages/) is a good summary of package management in Go.\r\n\r\n\r\n## Middlewares\r\n\r\nCore Middlewares:\r\n\r\n| Name | Description |\r\n|------|-------------|\r\n| **AccessLogApache** | Access log inspired by Apache mod_log_config |\r\n| **AccessLogJson** | Access log with records as JSON |\r\n| **AuthBasic** | Basic HTTP auth |\r\n| **ContentTypeChecker** | Verify the request content type |\r\n| **Cors** | CORS server side implementation |\r\n| **Gzip** | Compress the responses |\r\n| **If** | Conditionally execute a Middleware at runtime |\r\n| **JsonIndent** | Easy to read JSON |\r\n| **Jsonp** | Response as JSONP |\r\n| **PoweredBy** | Manage the X-Powered-By response header |\r\n| **Recorder** | Record the status code and content length in the Env |\r\n| **Status** | Memecached inspired stats about the requests |\r\n| **Timer** | Keep track of the elapsed time in the Env |\r\n\r\nThird Party Middlewares:\r\n\r\n| Name | Description |\r\n|------|-------------|\r\n| **[Statsd](https://github.com/ant0ine/go-json-rest-middleware-statsd)** | Send stats to a statsd server |\r\n| **[JWT](https://github.com/StephanDollberg/go-json-rest-middleware-jwt)** | Provides authentication via Json Web Tokens |\r\n| **[AuthToken](https://github.com/grayj/go-json-rest-middleware-tokenauth)** | Provides a Token Auth implementation |\r\n| **[SecureRedirect](https://github.com/clyphub/go-json-rest-middleware)** | Redirect clients from HTTP to HTTPS |\r\n\r\n*If you have a Go-Json-Rest compatible middleware, feel free to submit a PR to add it in this list, and in the examples.*\r\n\r\n\r\n## Examples\r\n\r\nAll the following examples can be found in dedicated examples repository: https://github.com/ant0ine/go-json-rest-examples\r\n\r\n### Basics\r\n\r\nFirst examples to try, as an introduction to go-json-rest.\r\n\r\n#### Hello World!\r\n\r\nTradition!\r\n\r\ncurl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/\r\n```\r\n\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.SetApp(rest.AppSimple(func(w rest.ResponseWriter, r *rest.Request) {\r\n\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t}))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### Lookup\r\n\r\nDemonstrate how to use the relaxed placeholder (notation `#paramName`).\r\nThis placeholder matches everything until the first `/`, including `.`\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/lookup/google.com\r\ncurl -i http://127.0.0.1:8080/lookup/notadomain\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype Message struct {\r\n\tBody string\r\n}\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/lookup/#host\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tip, err := net.LookupIP(req.PathParam(\"host\"))\r\n\t\t\tif err != nil {\r\n\t\t\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tw.WriteJson(&ip)\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### Countries\r\n\r\nDemonstrate simple POST GET and DELETE operations\r\n\r\ncurl demo:\r\n```\r\ncurl -i -H 'Content-Type: application/json' \\\r\n    -d '{\"Code\":\"FR\",\"Name\":\"France\"}' http://127.0.0.1:8080/countries\r\ncurl -i -H 'Content-Type: application/json' \\\r\n    -d '{\"Code\":\"US\",\"Name\":\"United States\"}' http://127.0.0.1:8080/countries\r\ncurl -i http://127.0.0.1:8080/countries/FR\r\ncurl -i http://127.0.0.1:8080/countries/US\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i -X DELETE http://127.0.0.1:8080/countries/FR\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i -X DELETE http://127.0.0.1:8080/countries/US\r\ncurl -i http://127.0.0.1:8080/countries\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"sync\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/countries\", GetAllCountries),\r\n\t\trest.Post(\"/countries\", PostCountry),\r\n\t\trest.Get(\"/countries/:code\", GetCountry),\r\n\t\trest.Delete(\"/countries/:code\", DeleteCountry),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nvar store = map[string]*Country{}\r\n\r\nvar lock = sync.RWMutex{}\r\n\r\nfunc GetCountry(w rest.ResponseWriter, r *rest.Request) {\r\n\tcode := r.PathParam(\"code\")\r\n\r\n\tlock.RLock()\r\n\tvar country *Country\r\n\tif store[code] != nil {\r\n\t\tcountry = &Country{}\r\n\t\t*country = *store[code]\r\n\t}\r\n\tlock.RUnlock()\r\n\r\n\tif country == nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(country)\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tlock.RLock()\r\n\tcountries := make([]Country, len(store))\r\n\ti := 0\r\n\tfor _, country := range store {\r\n\t\tcountries[i] = *country\r\n\t\ti++\r\n\t}\r\n\tlock.RUnlock()\r\n\tw.WriteJson(&countries)\r\n}\r\n\r\nfunc PostCountry(w rest.ResponseWriter, r *rest.Request) {\r\n\tcountry := Country{}\r\n\terr := r.DecodeJsonPayload(&country)\r\n\tif err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tif country.Code == \"\" {\r\n\t\trest.Error(w, \"country code required\", 400)\r\n\t\treturn\r\n\t}\r\n\tif country.Name == \"\" {\r\n\t\trest.Error(w, \"country name required\", 400)\r\n\t\treturn\r\n\t}\r\n\tlock.Lock()\r\n\tstore[country.Code] = &country\r\n\tlock.Unlock()\r\n\tw.WriteJson(&country)\r\n}\r\n\r\nfunc DeleteCountry(w rest.ResponseWriter, r *rest.Request) {\r\n\tcode := r.PathParam(\"code\")\r\n\tlock.Lock()\r\n\tdelete(store, code)\r\n\tlock.Unlock()\r\n\tw.WriteHeader(http.StatusOK)\r\n}\r\n\r\n```\r\n\r\n#### Users\r\n\r\nDemonstrate how to use Method Values.\r\n\r\nMethod Values have been [introduced in Go 1.1](https://golang.org/doc/go1.1#method_values).\r\n\r\nThis shows how to map a Route to a method of an instantiated object (i.e: receiver of the method)\r\n\r\ncurl demo:\r\n```\r\ncurl -i -H 'Content-Type: application/json' \\\r\n    -d '{\"Name\":\"Antoine\"}' http://127.0.0.1:8080/users\r\ncurl -i http://127.0.0.1:8080/users/0\r\ncurl -i -X PUT -H 'Content-Type: application/json' \\\r\n    -d '{\"Name\":\"Antoine Imbert\"}' http://127.0.0.1:8080/users/0\r\ncurl -i -X DELETE http://127.0.0.1:8080/users/0\r\ncurl -i http://127.0.0.1:8080/users\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"sync\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\tusers := Users{\r\n\t\tStore: map[string]*User{},\r\n\t}\r\n\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/users\", users.GetAllUsers),\r\n\t\trest.Post(\"/users\", users.PostUser),\r\n\t\trest.Get(\"/users/:id\", users.GetUser),\r\n\t\trest.Put(\"/users/:id\", users.PutUser),\r\n\t\trest.Delete(\"/users/:id\", users.DeleteUser),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\ntype User struct {\r\n\tId   string\r\n\tName string\r\n}\r\n\r\ntype Users struct {\r\n\tsync.RWMutex\r\n\tStore map[string]*User\r\n}\r\n\r\nfunc (u *Users) GetAllUsers(w rest.ResponseWriter, r *rest.Request) {\r\n\tu.RLock()\r\n\tusers := make([]User, len(u.Store))\r\n\ti := 0\r\n\tfor _, user := range u.Store {\r\n\t\tusers[i] = *user\r\n\t\ti++\r\n\t}\r\n\tu.RUnlock()\r\n\tw.WriteJson(&users)\r\n}\r\n\r\nfunc (u *Users) GetUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\tu.RLock()\r\n\tvar user *User\r\n\tif u.Store[id] != nil {\r\n\t\tuser = &User{}\r\n\t\t*user = *u.Store[id]\r\n\t}\r\n\tu.RUnlock()\r\n\tif user == nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(user)\r\n}\r\n\r\nfunc (u *Users) PostUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tuser := User{}\r\n\terr := r.DecodeJsonPayload(&user)\r\n\tif err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tu.Lock()\r\n\tid := fmt.Sprintf(\"%d\", len(u.Store)) // stupid\r\n\tuser.Id = id\r\n\tu.Store[id] = &user\r\n\tu.Unlock()\r\n\tw.WriteJson(&user)\r\n}\r\n\r\nfunc (u *Users) PutUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\tu.Lock()\r\n\tif u.Store[id] == nil {\r\n\t\trest.NotFound(w, r)\r\n\t\tu.Unlock()\r\n\t\treturn\r\n\t}\r\n\tuser := User{}\r\n\terr := r.DecodeJsonPayload(&user)\r\n\tif err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\tu.Unlock()\r\n\t\treturn\r\n\t}\r\n\tuser.Id = id\r\n\tu.Store[id] = &user\r\n\tu.Unlock()\r\n\tw.WriteJson(&user)\r\n}\r\n\r\nfunc (u *Users) DeleteUser(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\tu.Lock()\r\n\tdelete(u.Store, id)\r\n\tu.Unlock()\r\n\tw.WriteHeader(http.StatusOK)\r\n}\r\n\r\n```\r\n\r\n\r\n### Applications\r\n\r\nCommon use cases, found in many applications.\r\n\r\n#### API and static files\r\n\r\nCombine Go-Json-Rest with other handlers.\r\n\r\n`api.MakeHandler()` is a valid `http.Handler`, and can be combined with other handlers.\r\nIn this example the api handler is used under the `/api/` prefix, while a FileServer is instantiated under the `/static/` prefix.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/api/message\r\ncurl -i http://127.0.0.1:8080/static/main.go\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\r\n\thttp.Handle(\"/api/\", http.StripPrefix(\"/api\", api.MakeHandler()))\r\n\r\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static\", http.FileServer(http.Dir(\".\"))))\r\n\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\n```\r\n\r\n#### GORM\r\n\r\nDemonstrate basic CRUD operation using a store based on MySQL and GORM\r\n\r\n[GORM](https://github.com/jinzhu/gorm) is simple ORM library for Go.\r\nIn this example the same struct is used both as the GORM model and as the JSON model.\r\n\r\ncurl demo:\r\n```\r\ncurl -i -H 'Content-Type: application/json' \\\r\n    -d '{\"Message\":\"this is a test\"}' http://127.0.0.1:8080/reminders\r\ncurl -i http://127.0.0.1:8080/reminders/1\r\ncurl -i http://127.0.0.1:8080/reminders\r\ncurl -i -X PUT -H 'Content-Type: application/json' \\\r\n    -d '{\"Message\":\"is updated\"}' http://127.0.0.1:8080/reminders/1\r\ncurl -i -X DELETE http://127.0.0.1:8080/reminders/1\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t_ \"github.com/go-sql-driver/mysql\"\r\n\t\"github.com/jinzhu/gorm\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\r\n\ti := Impl{}\r\n\ti.InitDB()\r\n\ti.InitSchema()\r\n\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/reminders\", i.GetAllReminders),\r\n\t\trest.Post(\"/reminders\", i.PostReminder),\r\n\t\trest.Get(\"/reminders/:id\", i.GetReminder),\r\n\t\trest.Put(\"/reminders/:id\", i.PutReminder),\r\n\t\trest.Delete(\"/reminders/:id\", i.DeleteReminder),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\ntype Reminder struct {\r\n\tId        int64     `json:\"id\"`\r\n\tMessage   string    `sql:\"size:1024\" json:\"message\"`\r\n\tCreatedAt time.Time `json:\"createdAt\"`\r\n\tUpdatedAt time.Time `json:\"updatedAt\"`\r\n\tDeletedAt time.Time `json:\"-\"`\r\n}\r\n\r\ntype Impl struct {\r\n\tDB gorm.DB\r\n}\r\n\r\nfunc (i *Impl) InitDB() {\r\n\tvar err error\r\n\ti.DB, err = gorm.Open(\"mysql\", \"gorm:gorm@/gorm?charset=utf8&parseTime=True\")\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Got error when connect database, the error is '%v'\", err)\r\n\t}\r\n\ti.DB.LogMode(true)\r\n}\r\n\r\nfunc (i *Impl) InitSchema() {\r\n\ti.DB.AutoMigrate(&Reminder{})\r\n}\r\n\r\nfunc (i *Impl) GetAllReminders(w rest.ResponseWriter, r *rest.Request) {\r\n\treminders := []Reminder{}\r\n\ti.DB.Find(&reminders)\r\n\tw.WriteJson(&reminders)\r\n}\r\n\r\nfunc (i *Impl) GetReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\treminder := Reminder{}\r\n\tif i.DB.First(&reminder, id).Error != nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(&reminder)\r\n}\r\n\r\nfunc (i *Impl) PostReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\treminder := Reminder{}\r\n\tif err := r.DecodeJsonPayload(&reminder); err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tif err := i.DB.Save(&reminder).Error; err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(&reminder)\r\n}\r\n\r\nfunc (i *Impl) PutReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\r\n\tid := r.PathParam(\"id\")\r\n\treminder := Reminder{}\r\n\tif i.DB.First(&reminder, id).Error != nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\r\n\tupdated := Reminder{}\r\n\tif err := r.DecodeJsonPayload(&updated); err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\r\n\treminder.Message = updated.Message\r\n\r\n\tif err := i.DB.Save(&reminder).Error; err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.WriteJson(&reminder)\r\n}\r\n\r\nfunc (i *Impl) DeleteReminder(w rest.ResponseWriter, r *rest.Request) {\r\n\tid := r.PathParam(\"id\")\r\n\treminder := Reminder{}\r\n\tif i.DB.First(&reminder, id).Error != nil {\r\n\t\trest.NotFound(w, r)\r\n\t\treturn\r\n\t}\r\n\tif err := i.DB.Delete(&reminder).Error; err != nil {\r\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\r\n\t\treturn\r\n\t}\r\n\tw.WriteHeader(http.StatusOK)\r\n}\r\n\r\n```\r\n\r\n#### CORS\r\n\r\nDemonstrate how to setup CorsMiddleware around all the API endpoints.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.Use(&rest.CorsMiddleware{\r\n\t\tRejectNonCorsRequests: false,\r\n\t\tOriginValidator: func(origin string, request *rest.Request) bool {\r\n\t\t\treturn origin == \"http://my.other.host\"\r\n\t\t},\r\n\t\tAllowedMethods: []string{\"GET\", \"POST\", \"PUT\"},\r\n\t\tAllowedHeaders: []string{\r\n\t\t\t\"Accept\", \"Content-Type\", \"X-Custom-Header\", \"Origin\"},\r\n\t\tAccessControlAllowCredentials: true,\r\n\t\tAccessControlMaxAge:           3600,\r\n\t})\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/countries\", GetAllCountries),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n#### JSONP\r\n\r\nDemonstrate how to use the JSONP middleware.\r\n\r\ncurl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/\r\ncurl -i http://127.0.0.1:8080/?cb=parseResponse\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.Use(&rest.JsonpMiddleware{\r\n\t\tCallbackNameKey: \"cb\",\r\n\t})\r\n\tapi.SetApp(rest.AppSimple(func(w rest.ResponseWriter, r *rest.Request) {\r\n\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t}))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### Basic Auth\r\n\r\nDemonstrate how to setup AuthBasicMiddleware as a pre-routing middleware.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/\r\ncurl -i -u admin:admin http://127.0.0.1:8080/\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.Use(&rest.AuthBasicMiddleware{\r\n\t\tRealm: \"test zone\",\r\n\t\tAuthenticator: func(userId string, password string) bool {\r\n\t\t\tif userId == \"admin\" && password == \"admin\" {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t})\r\n\tapi.SetApp(rest.AppSimple(func(w rest.ResponseWriter, r *rest.Request) {\r\n\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t}))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### Status\r\n\r\nDemonstrate how to setup a `/.status` endpoint\r\n\r\nInspired by memcached \"stats\", this optional feature can be enabled to help monitoring the service.\r\nThis example shows how to enable the stats, and how to setup the `/.status` route.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/.status\r\ncurl -i http://127.0.0.1:8080/.status\r\n...\r\n```\r\n\r\nOutput example:\r\n```\r\n{\r\n  \"Pid\": 21732,\r\n  \"UpTime\": \"1m15.926272s\",\r\n  \"UpTimeSec\": 75.926272,\r\n  \"Time\": \"2013-03-04 08:00:27.152986 +0000 UTC\",\r\n  \"TimeUnix\": 1362384027,\r\n  \"StatusCodeCount\": {\r\n        \"200\": 53,\r\n        \"404\": 11\r\n  },\r\n  \"TotalCount\": 64,\r\n  \"TotalResponseTime\": \"16.777ms\",\r\n  \"TotalResponseTimeSec\": 0.016777,\r\n  \"AverageResponseTime\": \"262.14us\",\r\n  \"AverageResponseTimeSec\": 0.00026214\r\n}\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tstatusMw := &rest.StatusMiddleware{}\r\n\tapi.Use(statusMw)\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/.status\", func(w rest.ResponseWriter, r *rest.Request) {\r\n\t\t\tw.WriteJson(statusMw.GetStatus())\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### Status Auth\r\n\r\nDemonstrate how to setup a /.status endpoint protected with basic authentication.\r\n\r\nThis is a good use case of middleware applied to only one API endpoint.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/countries\r\ncurl -i http://127.0.0.1:8080/.status\r\ncurl -i -u admin:admin http://127.0.0.1:8080/.status\r\n...\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tstatusMw := &rest.StatusMiddleware{}\r\n\tapi.Use(statusMw)\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tauth := &rest.AuthBasicMiddleware{\r\n\t\tRealm: \"test zone\",\r\n\t\tAuthenticator: func(userId string, password string) bool {\r\n\t\t\tif userId == \"admin\" && password == \"admin\" {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t},\r\n\t}\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/countries\", GetAllCountries),\r\n\t\trest.Get(\"/.status\", auth.MiddlewareFunc(\r\n\t\t\tfunc(w rest.ResponseWriter, r *rest.Request) {\r\n\t\t\t\tw.WriteJson(statusMw.GetStatus())\r\n\t\t\t},\r\n\t\t)),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\ntype Country struct {\r\n\tCode string\r\n\tName string\r\n}\r\n\r\nfunc GetAllCountries(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(\r\n\t\t[]Country{\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"FR\",\r\n\t\t\t\tName: \"France\",\r\n\t\t\t},\r\n\t\t\tCountry{\r\n\t\t\t\tCode: \"US\",\r\n\t\t\t\tName: \"United States\",\r\n\t\t\t},\r\n\t\t},\r\n\t)\r\n}\r\n\r\n```\r\n\r\n\r\n### Advanced\r\n\r\nMore advanced use cases.\r\n\r\n#### JWT\r\n\r\nDemonstrates how to use the [Json Web Token Auth Middleware](https://github.com/StephanDollberg/go-json-rest-middleware-jwt) to authenticate via a JWT token.\r\n\r\ncurl demo:\r\n``` sh\r\ncurl -d '{\"username\": \"admin\", \"password\": \"admin\"}' -H \"Content-Type:application/json\" http://localhost:8080/api/login\r\ncurl -H \"Authorization:Bearer TOKEN_RETURNED_FROM_ABOVE\" http://localhost:8080/api/auth_test\r\ncurl -H \"Authorization:Bearer TOKEN_RETURNED_FROM_ABOVE\" http://localhost:8080/api/refresh_token\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n\r\n\t\"github.com/StephanDollberg/go-json-rest-middleware-jwt\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n)\r\n\r\nfunc handle_auth(w rest.ResponseWriter, r *rest.Request) {\r\n\tw.WriteJson(map[string]string{\"authed\": r.Env[\"REMOTE_USER\"].(string)})\r\n}\r\n\r\nfunc main() {\r\n\tjwt_middleware := &jwt.JWTMiddleware{\r\n\t\tKey:        []byte(\"secret key\"),\r\n\t\tRealm:      \"jwt auth\",\r\n\t\tTimeout:    time.Hour,\r\n\t\tMaxRefresh: time.Hour * 24,\r\n\t\tAuthenticator: func(userId string, password string) bool {\r\n\t\t\treturn userId == \"admin\" && password == \"admin\"\r\n\t\t}}\r\n\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\t// we use the IfMiddleware to remove certain paths from needing authentication\r\n\tapi.Use(&rest.IfMiddleware{\r\n\t\tCondition: func(request *rest.Request) bool {\r\n\t\t\treturn request.URL.Path != \"/login\"\r\n\t\t},\r\n\t\tIfTrue: jwt_middleware,\r\n\t})\r\n\tapi_router, _ := rest.MakeRouter(\r\n\t\trest.Post(\"/login\", jwt_middleware.LoginHandler),\r\n\t\trest.Get(\"/auth_test\", handle_auth),\r\n\t\trest.Get(\"/refresh_token\", jwt_middleware.RefreshHandler),\r\n\t)\r\n\tapi.SetApp(api_router)\r\n\r\n\thttp.Handle(\"/api/\", http.StripPrefix(\"/api\", api.MakeHandler()))\r\n\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\n```\r\n\r\n#### Streaming\r\n\r\nDemonstrate a streaming REST API, where the data is \"flushed\" to the client ASAP.\r\n\r\nThe stream format is a Line Delimited JSON.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/stream\r\n```\r\n\r\nOutput:\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\nDate: Sun, 16 Feb 2014 00:39:19 GMT\r\nTransfer-Encoding: chunked\r\n\r\n{\"Name\":\"thing #1\"}\r\n{\"Name\":\"thing #2\"}\r\n{\"Name\":\"thing #3\"}\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(&rest.AccessLogApacheMiddleware{})\r\n\tapi.Use(rest.DefaultCommonStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/stream\", StreamThings),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\ntype Thing struct {\r\n\tName string\r\n}\r\n\r\nfunc StreamThings(w rest.ResponseWriter, r *rest.Request) {\r\n\tcpt := 0\r\n\tfor {\r\n\t\tcpt++\r\n\t\tw.WriteJson(\r\n\t\t\t&Thing{\r\n\t\t\t\tName: fmt.Sprintf(\"thing #%d\", cpt),\r\n\t\t\t},\r\n\t\t)\r\n\t\tw.(http.ResponseWriter).Write([]byte(\"\\n\"))\r\n\t\t// Flush the buffer to client\r\n\t\tw.(http.Flusher).Flush()\r\n\t\t// wait 3 seconds\r\n\t\ttime.Sleep(time.Duration(3) * time.Second)\r\n\t}\r\n}\r\n\r\n```\r\n\r\n#### Non JSON payload\r\n\r\nExceptional use of non JSON payloads.\r\n\r\nThe ResponseWriter implementation provided by go-json-rest is designed\r\nto build JSON responses. In order to serve different kind of content,\r\nit is recommended to either:\r\na) use another server and configure CORS\r\n   (see the cors/ example)\r\nb) combine the api.MakeHandler() with another http.Handler\r\n   (see api-and-static/ example)\r\n\r\nThat been said, exceptionally, it can be convenient to return a\r\ndifferent content type on a JSON endpoint. In this case, setting the\r\nContent-Type and using the type assertion to access the Write method\r\nis enough. As shown in this example.\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/message.txt\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/message.txt\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\r\n\t\t\tw.(http.ResponseWriter).Write([]byte(\"Hello World!\"))\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### API Versioning\r\n\r\nFirst, API versioning is not easy and you may want to favor a mechanism that uses only backward compatible changes and deprecation cycles.\r\n\r\nThat been said, here is an example of API versioning using [Semver](http://semver.org/)\r\n\r\nIt defines a middleware that parses the version, checks a min and a max, and makes it available in the `request.Env`.\r\n\r\ncurl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/api/1.0.0/message\r\ncurl -i http://127.0.0.1:8080/api/2.0.0/message\r\ncurl -i http://127.0.0.1:8080/api/2.0.1/message\r\ncurl -i http://127.0.0.1:8080/api/0.0.1/message\r\ncurl -i http://127.0.0.1:8080/api/4.0.1/message\r\n\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/coreos/go-semver/semver\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\ntype SemVerMiddleware struct {\r\n\tMinVersion string\r\n\tMaxVersion string\r\n}\r\n\r\nfunc (mw *SemVerMiddleware) MiddlewareFunc(handler rest.HandlerFunc) rest.HandlerFunc {\r\n\r\n\tminVersion, err := semver.NewVersion(mw.MinVersion)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tmaxVersion, err := semver.NewVersion(mw.MaxVersion)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\treturn func(writer rest.ResponseWriter, request *rest.Request) {\r\n\r\n\t\tversion, err := semver.NewVersion(request.PathParam(\"version\"))\r\n\t\tif err != nil {\r\n\t\t\trest.Error(\r\n\t\t\t\twriter,\r\n\t\t\t\t\"Invalid version: \"+err.Error(),\r\n\t\t\t\thttp.StatusBadRequest,\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif version.LessThan(*minVersion) {\r\n\t\t\trest.Error(\r\n\t\t\t\twriter,\r\n\t\t\t\t\"Min supported version is \"+minVersion.String(),\r\n\t\t\t\thttp.StatusBadRequest,\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif maxVersion.LessThan(*version) {\r\n\t\t\trest.Error(\r\n\t\t\t\twriter,\r\n\t\t\t\t\"Max supported version is \"+maxVersion.String(),\r\n\t\t\t\thttp.StatusBadRequest,\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\trequest.Env[\"VERSION\"] = version\r\n\t\thandler(writer, request)\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\r\n\tsvmw := SemVerMiddleware{\r\n\t\tMinVersion: \"1.0.0\",\r\n\t\tMaxVersion: \"3.0.0\",\r\n\t}\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/#version/message\", svmw.MiddlewareFunc(\r\n\t\t\tfunc(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\t\tversion := req.Env[\"VERSION\"].(*semver.Version)\r\n\t\t\t\tif version.Major == 2 {\r\n\t\t\t\t\t// http://en.wikipedia.org/wiki/Second-system_effect\r\n\t\t\t\t\tw.WriteJson(map[string]string{\r\n\t\t\t\t\t\t\"Body\": \"Hello broken World!\",\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tw.WriteJson(map[string]string{\r\n\t\t\t\t\t\t\"Body\": \"Hello World!\",\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t)),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\thttp.Handle(\"/api/\", http.StripPrefix(\"/api\", api.MakeHandler()))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}\r\n\r\n```\r\n\r\n#### Statsd\r\n\r\nDemonstrate how to use the [Statsd Middleware](https://github.com/ant0ine/go-json-rest-middleware-statsd) to collect statistics about the requests/reponses.\r\nThis middleware is based on the [g2s](https://github.com/peterbourgon/g2s) statsd client.\r\n\r\ncurl demo:\r\n``` sh\r\n# start statsd server\r\n# monitor network\r\nngrep -d any port 8125\r\n\r\ncurl -i http://127.0.0.1:8080/message\r\ncurl -i http://127.0.0.1:8080/doesnotexist\r\n\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest-middleware-statsd\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(&statsd.StatsdMiddleware{})\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.SetApp(rest.AppSimple(func(w rest.ResponseWriter, req *rest.Request) {\r\n\r\n\t\t// take more than 1ms so statsd can report it\r\n\t\ttime.Sleep(100 * time.Millisecond)\r\n\r\n\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t}))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### NewRelic\r\n\r\nNewRelic integration based on the GoRelic plugin: [github.com/yvasiyarov/gorelic](http://github.com/yvasiyarov/gorelic)\r\n\r\ncurl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/yvasiyarov/go-metrics\"\r\n\t\"github.com/yvasiyarov/gorelic\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\ntype NewRelicMiddleware struct {\r\n\tLicense string\r\n\tName    string\r\n\tVerbose bool\r\n\tagent   *gorelic.Agent\r\n}\r\n\r\nfunc (mw *NewRelicMiddleware) MiddlewareFunc(handler rest.HandlerFunc) rest.HandlerFunc {\r\n\r\n\tmw.agent = gorelic.NewAgent()\r\n\tmw.agent.NewrelicLicense = mw.License\r\n\tmw.agent.HTTPTimer = metrics.NewTimer()\r\n\tmw.agent.Verbose = mw.Verbose\r\n\tmw.agent.NewrelicName = mw.Name\r\n\tmw.agent.CollectHTTPStat = true\r\n\tmw.agent.Run()\r\n\r\n\treturn func(writer rest.ResponseWriter, request *rest.Request) {\r\n\r\n\t\thandler(writer, request)\r\n\r\n\t\t// the timer middleware keeps track of the time\r\n\t\tstartTime := request.Env[\"START_TIME\"].(*time.Time)\r\n\t\tmw.agent.HTTPTimer.UpdateSince(*startTime)\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.Use(&NewRelicMiddleware{\r\n\t\tLicense: \"<REPLACE WITH THE LICENSE KEY>\",\r\n\t\tName:    \"<REPLACE WITH THE APP NAME>\",\r\n\t\tVerbose: true,\r\n\t})\r\n\tapi.SetApp(rest.AppSimple(func(w rest.ResponseWriter, r *rest.Request) {\r\n\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t}))\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### Graceful Shutdown\r\n\r\nThis example uses [github.com/stretchr/graceful](https://github.com/stretchr/graceful) to try to be nice with the clients waiting for responses during a server shutdown (or restart).\r\nThe HTTP response takes 10 seconds to be completed, printing a message on the wire every second.\r\n10 seconds is also the timeout set for the graceful shutdown.\r\nYou can play with these numbers to show that the server waits for the responses to complete.\r\n\r\ncurl demo:\r\n``` sh\r\ncurl -i http://127.0.0.1:8080/message\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/stretchr/graceful\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\t\"time\"\r\n)\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tfor cpt := 1; cpt <= 10; cpt++ {\r\n\r\n\t\t\t\t// wait 1 second\r\n\t\t\t\ttime.Sleep(time.Duration(1) * time.Second)\r\n\r\n\t\t\t\tw.WriteJson(map[string]string{\r\n\t\t\t\t\t\"Message\": fmt.Sprintf(\"%d seconds\", cpt),\r\n\t\t\t\t})\r\n\t\t\t\tw.(http.ResponseWriter).Write([]byte(\"\\n\"))\r\n\r\n\t\t\t\t// Flush the buffer to client\r\n\t\t\t\tw.(http.Flusher).Flush()\r\n\t\t\t}\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\r\n\tserver := &graceful.Server{\r\n\t\tTimeout: 10 * time.Second,\r\n\t\tServer: &http.Server{\r\n\t\t\tAddr:    \":8080\",\r\n\t\t\tHandler: api.MakeHandler(),\r\n\t\t},\r\n\t}\r\n\r\n\tlog.Fatal(server.ListenAndServe())\r\n}\r\n\r\n```\r\n\r\n#### SPDY\r\n\r\nDemonstrate how to use SPDY with https://github.com/shykes/spdy-go\r\n\r\nFor a command line client, install spdycat from:\r\nhttps://github.com/tatsuhiro-t/spdylay\r\n\r\nspdycat demo:\r\n```\r\nspdycat -v --no-tls -2 http://localhost:8080/users/0\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"github.com/shykes/spdy-go\"\r\n\t\"log\"\r\n)\r\n\r\ntype User struct {\r\n\tId   string\r\n\tName string\r\n}\r\n\r\nfunc GetUser(w rest.ResponseWriter, req *rest.Request) {\r\n\tuser := User{\r\n\t\tId:   req.PathParam(\"id\"),\r\n\t\tName: \"Antoine\",\r\n\t}\r\n\tw.WriteJson(&user)\r\n}\r\n\r\nfunc main() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/users/:id\", GetUser),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(spdy.ListenAndServeTCP(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n#### GAE\r\n\r\nDemonstrate a simple Google App Engine app\r\n\r\nHere are my steps to make it work with the GAE SDK.\r\n(Probably not the best ones)\r\n\r\nAssuming that go-json-rest is installed using \"go get\"\r\nand that the GAE SDK is also installed.\r\n\r\nSetup:\r\n * copy this examples/gae/ dir outside of the go-json-rest/ tree\r\n * cd gae/\r\n * mkdir -p github.com/ant0ine\r\n * cp -r $GOPATH/src/github.com/ant0ine/go-json-rest github.com/ant0ine/go-json-rest\r\n * rm -rf github.com/ant0ine/go-json-rest/examples/\r\n * path/to/google_appengine/dev_appserver.py .\r\n\r\ncurl demo:\r\n```\r\ncurl -i http://127.0.0.1:8080/message\r\n```\r\n\r\ncode:\r\n``` go\r\npackage gaehelloworld\r\n\r\nimport (\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc init() {\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\trouter, err := rest.MakeRouter(\r\n\t\t&rest.Get(\"/message\", func(w rest.ResponseWriter, req *rest.Request) {\r\n\t\t\tw.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tapi.SetApp(router)\r\n\thttp.Handle(\"/\", api.MakeHandler())\r\n}\r\n\r\n```\r\n\r\n#### Websocket\r\n\r\nDemonstrate how to run websocket in go-json-rest\r\n\r\ngo client demo:\r\n```go\r\norigin := \"http://localhost:8080/\"\r\nurl := \"ws://localhost:8080/ws\"\r\nws, err := websocket.Dial(url, \"\", origin)\r\nif err != nil {\r\n\tlog.Fatal(err)\r\n}\r\nif _, err := ws.Write([]byte(\"hello, world\\n\")); err != nil {\r\n\tlog.Fatal(err)\r\n}\r\nvar msg = make([]byte, 512)\r\nvar n int\r\nif n, err = ws.Read(msg); err != nil {\r\n\tlog.Fatal(err)\r\n}\r\nlog.Printf(\"Received: %s.\", msg[:n])\r\n```\r\n\r\ncode:\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/ant0ine/go-json-rest/rest\"\r\n\t\"golang.org/x/net/websocket\"\r\n)\r\n\r\nfunc main() {\r\n\twsHandler := websocket.Handler(func(ws *websocket.Conn) {\r\n\t\tio.Copy(ws, ws)\r\n\t})\r\n\r\n\trouter, err := rest.MakeRouter(\r\n\t\trest.Get(\"/ws\", func(w rest.ResponseWriter, r *rest.Request) {\r\n\t\t\twsHandler.ServeHTTP(w.(http.ResponseWriter), r.Request)\r\n\t\t}),\r\n\t)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\r\n\tapi := rest.NewApi()\r\n\tapi.Use(rest.DefaultDevStack...)\r\n\tapi.SetApp(router)\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", api.MakeHandler()))\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## External Documentation\r\n\r\n- [Online Documentation (godoc.org)](https://godoc.org/github.com/ant0ine/go-json-rest/rest)\r\n\r\nOld v1 blog posts:\r\n\r\n- [(Blog Post) Introducing Go-Json-Rest] (http://blog.ant0ine.com/typepad/2013/04/introducing-go-json-rest.html)\r\n- [(Blog Post) Better URL Routing ?] (http://blog.ant0ine.com/typepad/2013/02/better-url-routing-golang-1.html)\r\n\r\n\r\n## Version 3 release notes\r\n\r\n### What's New in v3\r\n\r\n* Public Middlewares. (12 included in the package)\r\n* A new App interface. (the router being the provided App)\r\n* A new Api object that manages the Middlewares and the App.\r\n* Optional and interchangeable App/router.\r\n\r\n### Here is for instance the new minimal \"Hello World!\"\r\n\r\n```go\r\napi := rest.NewApi()\r\napi.Use(rest.DefaultDevStack...)\r\napi.SetApp(rest.AppSimple(func(w rest.ResponseWriter, r *rest.Request) {\r\n        w.WriteJson(map[string]string{\"Body\": \"Hello World!\"})\r\n}))\r\nhttp.ListenAndServe(\":8080\", api.MakeHandler())\r\n```\r\n\r\n*All 19 examples have been updated to use the new API. [See here](https://github.com/ant0ine/go-json-rest#examples)*\r\n\r\n### Deprecating the ResourceHandler\r\n\r\nV3 is about deprecating the ResourceHandler in favor of a new API that exposes the Middlewares. As a consequence, all the Middlewares are now public, and the new Api object helps putting them together as a stack. Some default stack configurations are offered. The router is now an App that sits on top of the stack of Middlewares. Which means that the router is no longer required to use Go-Json-Rest.\r\n\r\n*Design ideas and discussion [See here](https://github.com/ant0ine/go-json-rest/issues/110)*\r\n\r\n\r\n## Migration guide from v2 to v3\r\n\r\nV3 introduces an API change (see [Semver](http://semver.org/)). But it was possible to maintain backward compatibility, and so, ResourceHandler still works.\r\nResourceHandler does the same thing as in V2, **but it is now considered as deprecated, and will be removed in a few months**. In the meantime, it logs a\r\ndeprecation warning.\r\n\r\n### How to map the ResourceHandler options to the new stack of middlewares ?\r\n\r\n* `EnableGzip bool`: Just include GzipMiddleware in the stack of middlewares.\r\n* `DisableJsonIndent bool`: Just don't include JsonIndentMiddleware in the stack of middlewares.\r\n* `EnableStatusService bool`: Include StatusMiddleware in the stack and keep a reference to it to access GetStatus().\r\n* `EnableResponseStackTrace bool`: Same exact option but moved to RecoverMiddleware.\r\n* `EnableLogAsJson bool`: Include AccessLogJsonMiddleware, and possibly remove AccessLogApacheMiddleware.\r\n* `EnableRelaxedContentType bool`: Just don't include ContentTypeCheckerMiddleware.\r\n* `OuterMiddlewares []Middleware`: You are now building the full stack, OuterMiddlewares are the first in the list.\r\n* `PreRoutingMiddlewares []Middleware`: You are now building the full stack, OuterMiddlewares are the last in the list.\r\n* `Logger *log.Logger`: Same option but moved to AccessLogApacheMiddleware and AccessLogJsonMiddleware.\r\n* `LoggerFormat AccessLogFormat`: Same exact option but moved to AccessLogApacheMiddleware.\r\n* `DisableLogger bool`: Just don't include any access log middleware.\r\n* `ErrorLogger *log.Logger`: Same exact option but moved to RecoverMiddleware.\r\n* `XPoweredBy string`: Same exact option but moved to PoweredByMiddleware.\r\n* `DisableXPoweredBy bool`: Just don't include PoweredByMiddleware.\r\n\r\n\r\n## Version 2 release notes\r\n\r\n* Middlewares, the notion of middleware is now formally defined. They can be setup as global pre-routing Middlewares wrapping all the endpoints, or on a per endpoint basis.\r\nIn fact the internal code of **go-json-rest** is itself implemented with Middlewares, they are just hidden behind configuration boolean flags to make these very common options even easier to use.\r\n\r\n* A new ResponseWriter. This is now an interface, and allows Middlewares to wrap the writer. The provided writer implements, in addition of *rest.ResponseWriter*, *http.Flusher*, *http.CloseNotifier*, *http.Hijacker*, and *http.ResponseWriter*. A lot more Go-ish, and very similar to `net/http`.\r\n\r\n* The AuthBasic and CORS Middlewares have been added. More to come in the future.\r\n\r\n* Faster, more tasks are performed at init time, and less for each request.\r\n\r\n* New documentation, with more examples.\r\n\r\n* A lot of other small improvements, See the [Migration guide to v2](#migration-guide-from-v1-to-v2)\r\n\r\n\r\n## Migration guide from v1 to v2\r\n\r\n**Go-Json-Rest** follows [Semver](http://semver.org/) and a few breaking changes have been introduced with the v2.\r\n\r\n\r\n#### The import path has changed to `github.com/ant0ine/go-json-rest/rest`\r\n\r\nThis is more conform to Go style, and makes [goimports](https://godoc.org/code.google.com/p/go.tools/cmd/goimports) work.\r\n\r\nThis:\r\n``` go\r\nimport (\r\n        \"github.com/ant0ine/go-json-rest\"\r\n)\r\n```\r\nhas to be changed to this:\r\n``` go\r\nimport (\r\n        \"github.com/ant0ine/go-json-rest/rest\"\r\n)\r\n```\r\n\r\n\r\n#### rest.ResponseWriter is now an interface\r\n\r\nThis change allows the `ResponseWriter` to be wrapped, like the one of the `net/http` package.\r\nThis is much more powerful, and allows the creation of Middlewares that wrap the writer. The gzip option, for instance, uses this to encode the payload (see gzip.go).\r\n\r\nThis:\r\n``` go\r\nfunc (w *rest.ResponseWriter, req *rest.Request) {\r\n        ...\r\n}\r\n```\r\nhas to be changed to this:\r\n``` go\r\nfunc (w rest.ResponseWriter, req *rest.Request) {\r\n        ...\r\n}\r\n```\r\n\r\n\r\n#### SetRoutes now takes pointers to Route\r\n\r\nInstead of copying Route structures everywhere, pointers are now used. This is more elegant, more efficient, and will allow more sophisticated Route manipulations in the future (like reverse route resolution).\r\n\r\nThis:\r\n``` go\r\nhandler.SetRoutes(\r\n\t\trest.Route{\r\n\t\t      // ...\r\n\t\t},\r\n)\r\n```\r\nhas to be changed to this:\r\n``` go\r\nhandler.SetRoutes(\r\n\t\t&rest.Route{\r\n\t\t      // ...\r\n\t\t},\r\n)\r\n```\r\n\r\n\r\n####  The notion of Middleware is now formally defined\r\n\r\nA middleware is an object satisfying this interface:\r\n``` go\r\ntype Middleware interface {\r\n\tMiddlewareFunc(handler HandlerFunc) HandlerFunc\r\n}\r\n```\r\n\r\nCode using PreRoutingMiddleware will have to be adapted to provide a list of Middleware objects.\r\nSee the [Basic Auth example](https://github.com/ant0ine/go-json-rest-examples/blob/master/auth-basic/main.go).\r\n\r\n\r\n#### Flush(), CloseNotify() and Write() are not directly exposed anymore\r\n\r\nThey used to be public methods of the ResponseWriter. The implementation is still there but a type assertion of the corresponding interface is now necessary.\r\nRegarding these features, a rest.ResponseWriter now behaves exactly as the http.ResponseWriter implementation provided by net/http.\r\n\r\nThis:\r\n``` go\r\nwriter.Flush()\r\n```\r\nhas to be changed to this:\r\n``` go\r\nwriter.(http.Flusher).Flush()\r\n```\r\n\r\n\r\n#### The /.status endpoint is not created automatically anymore\r\n\r\nThe route has to be manually defined.\r\nSee the [Status example](https://github.com/ant0ine/go-json-rest-examples/blob/master/status/main.go).\r\nThis is more flexible (the route is customizable), and allows combination with Middlewarres.\r\nSee for instance how to [protect this status endpoint with the AuthBasic middleware](https://github.com/ant0ine/go-json-rest-examples/blob/master/status-auth/main.go).\r\n\r\n\r\n#### Request utility methods have changed\r\n\r\nOverall, they provide the same features, but with two methods instead of three, better names, and without the confusing `UriForWithParams`.\r\n\r\n- `func (r *Request) UriBase() url.URL` is now `func (r *Request) BaseUrl() *url.URL`, Note the pointer as the returned value.\r\n\r\n- `func (r *Request) UriForWithParams(path string, parameters map[string][]string) url.URL` is now `func (r *Request) UrlFor(path string, queryParams map[string][]string) *url.URL`.\r\n\r\n- `func (r *Request) UriFor(path string) url.URL` has be removed.\r\n\r\n\r\n## Thanks\r\n\r\n- [Franck Cuny](https://github.com/franckcuny)\r\n- [Yann Kerhervé](https://github.com/yannk)\r\n- [Ask Bjørn Hansen](https://github.com/abh)\r\n- [Paul Lam](https://github.com/Quantisan)\r\n- [Thanabodee Charoenpiriyakij](https://github.com/wingyplus)\r\n- [Sebastien Estienne](https://github.com/sebest)\r\n\r\n\r\nCopyright (c) 2013-2015 Antoine Imbert\r\n\r\n[MIT License](https://github.com/ant0ine/go-json-rest/blob/master/LICENSE)\r\n","google":"UA-309210-5","note":"Don't delete this file! It's used internally to help with page regeneration."}